module Rserve
  # An R-centric container for storing data frame-ish data
  class DataFrame

    # the colnames can be set explicitly, or they will be generated by
    # data.keys
    attr_writer :colnames
    # rownames as an array of Integers or Strings.  nil by default.
    attr_accessor :rownames
    # a hash where the keys are the column names and the values are arrays of
    # data
    attr_accessor :data

    # takes an array of structs and returns a data frame object
    def self.from_structs(array)
      names = array.first.members
      lengthwise_arrays = names.map { Array.new(array.length) }
      array.each_with_index do |struct,m|
        struct.values.each_with_index do |val,n|
          lengthwise_arrays[n][m] = val
        end
      end
      data = {}
      names.zip(lengthwise_arrays) do |name, lengthwise_array|
        data[name] = lengthwise_array
      end
      self.new(data)
    end

    # will use colnames if they've been set, otherwise data.keys
    def colnames
      @colnames || @data.keys 
    end

    # takes an ordered hash, where the col_name is the key and the data rows
    # are an array of values.  The default ordering of the hash keys will be
    # used as the colnames.  This works great for ruby 1.9 (which remembers
    # ordering).  Use an OrderedHash for ruby 1.8.  The rownames can be used
    # to specify the names of the rows (remains nil if no values specified)
    def initialize(ordered_hash, rownames=nil)
      @data = ordered_hash
      @rownames = rownames
    end

    def ==(other)
      (self.data == other.data) && (self.rownames == other.rownames)
    end
  end

end

class Hash
  def to_dataframe(rownames=nil)
    obj = Rserve::DataFrame.new(self)
    obj.rownames = rownames if rownames
    obj
  end
end
